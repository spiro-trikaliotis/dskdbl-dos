// $Id: FORM.CPP,v 1.2 2005/01/10 10:47:37 trikalio Exp $
//

// Achtung!!!
//   Vor dem Aufruf dieser Funktion muá schon ein Zugriff auf das
//   Diskettenlaufwerk erfolgt sein! (sonst Meldung: Datentr„ger gewechselt!)

#pragma hdrfile "format.sym"
#include <iostream.h>
#include <stdlib.h>
#pragma hdrstop

#define FORMAT

enum bool { true = (1==1), false = (1==0) };

typedef unsigned char BYTE;

static bool bReset = true;

static BYTE bootblk[] =
   { 0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53,
     0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x01, 0x00,
     0x02, 0xE0, 0x00, 0x40, 0x0B, 0xF0, 0x09, 0x00,
     0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29,

     // dies hier ist die Volume Serial No: 1234:5678
     0x78, 0x56, 0x34, 0x12,

		       0x4E, 0x4F, 0x20, 0x4E, 0x41,
     0x4D, 0x45, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41,
     0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0xFA, 0x33,
     0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0x16, 0x07,
     0xBB, 0x78, 0x00, 0x36, 0xC5, 0x37, 0x1E, 0x56,
     0x16, 0x53, 0xBF, 0x3E, 0x7C, 0xB9, 0x0B, 0x00,
     0xFC, 0xF3, 0xA4, 0x06, 0x1F, 0xC6, 0x45, 0xFE,
     0x0F, 0x8B, 0x0E, 0x18, 0x7C, 0x88, 0x4D, 0xF9,
     0x89, 0x47, 0x02, 0xC7, 0x07, 0x3E, 0x7C, 0xFB,
     0xCD, 0x13, 0x72, 0x79, 0x33, 0xC0, 0x39, 0x06,
     0x13, 0x7C, 0x74, 0x08, 0x8B, 0x0E, 0x13, 0x7C,
     0x89, 0x0E, 0x20, 0x7C, 0xA0, 0x10, 0x7C, 0xF7,
     0x26, 0x16, 0x7C, 0x03, 0x06, 0x1C, 0x7C, 0x13,
     0x16, 0x1E, 0x7C, 0x03, 0x06, 0x0E, 0x7C, 0x83,
     0xD2, 0x00, 0xA3, 0x50, 0x7C, 0x89, 0x16, 0x52,
     0x7C, 0xA3, 0x49, 0x7C, 0x89, 0x16, 0x4B, 0x7C,
     0xB8, 0x20, 0x00, 0xF7, 0x26, 0x11, 0x7C, 0x8B,
     0x1E, 0x0B, 0x7C, 0x03, 0xC3, 0x48, 0xF7, 0xF3,
     0x01, 0x06, 0x49, 0x7C, 0x83, 0x16, 0x4B, 0x7C,
     0x00, 0xBB, 0x00, 0x05, 0x8B, 0x16, 0x52, 0x7C,
     0xA1, 0x50, 0x7C, 0xE8, 0x92, 0x00, 0x72, 0x1D,
     0xB0, 0x01, 0xE8, 0xAC, 0x00, 0x72, 0x16, 0x8B,
     0xFB, 0xB9, 0x0B, 0x00, 0xBE, 0xDF, 0x7D, 0xF3,
     0xA6, 0x75, 0x0A, 0x8D, 0x7F, 0x20, 0xB9, 0x0B,
     0x00, 0xF3, 0xA6, 0x74, 0x18, 0xBE, 0x9E, 0x7D,
     0xE8, 0x5F, 0x00, 0x33, 0xC0, 0xCD, 0x16, 0x5E,
     0x1F, 0x8F, 0x04, 0x8F, 0x44, 0x02, 0xCD, 0x19,
     0x58, 0x58, 0x58, 0xEB, 0xE8, 0x8B, 0x47, 0x1A,
     0x48, 0x48, 0x8A, 0x1E, 0x0D, 0x7C, 0x32, 0xFF,
     0xF7, 0xE3, 0x03, 0x06, 0x49, 0x7C, 0x13, 0x16,
     0x4B, 0x7C, 0xBB, 0x00, 0x07, 0xB9, 0x03, 0x00,
     0x50, 0x52, 0x51, 0xE8, 0x3A, 0x00, 0x72, 0xD8,
     0xB0, 0x01, 0xE8, 0x54, 0x00, 0x59, 0x5A, 0x58,
     0x72, 0xBB, 0x05, 0x01, 0x00, 0x83, 0xD2, 0x00,
     0x03, 0x1E, 0x0B, 0x7C, 0xE2, 0xE2, 0x8A, 0x2E,
     0x15, 0x7C, 0x8A, 0x16, 0x24, 0x7C, 0x8B, 0x1E,
     0x49, 0x7C, 0xA1, 0x4B, 0x7C, 0xEA, 0x00, 0x00,
     0x70, 0x00, 0xAC, 0x0A, 0xC0, 0x74, 0x29, 0xB4,
     0x0E, 0xBB, 0x07, 0x00, 0xCD, 0x10, 0xEB, 0xF2,
     0x3B, 0x16, 0x18, 0x7C, 0x73, 0x19, 0xF7, 0x36,
     0x18, 0x7C, 0xFE, 0xC2, 0x88, 0x16, 0x4F, 0x7C,
     0x33, 0xD2, 0xF7, 0x36, 0x1A, 0x7C, 0x88, 0x16,
     0x25, 0x7C, 0xA3, 0x4D, 0x7C, 0xF8, 0xC3, 0xF9,
     0xC3, 0xB4, 0x02, 0x8B, 0x16, 0x4D, 0x7C, 0xB1,
     0x06, 0xD2, 0xE6, 0x0A, 0x36, 0x4F, 0x7C, 0x8B,
     0xCA, 0x86, 0xE9, 0x8A, 0x16, 0x24, 0x7C, 0x8A,
     0x36, 0x25, 0x7C, 0xCD, 0x13, 0xC3, 0x0D, 0x0A,
     0x4B, 0x65, 0x69, 0x6E, 0x20, 0x53, 0x79, 0x73,
     0x74, 0x65, 0x6D, 0x20, 0x6F, 0x64, 0x65, 0x72,
     0x20, 0x4C, 0x61, 0x75, 0x66, 0x77, 0x65, 0x72,
     0x6B, 0x73, 0x66, 0x65, 0x68, 0x6C, 0x65, 0x72,
     0x0D, 0x0A, 0x57, 0x65, 0x63, 0x68, 0x73, 0x65,
     0x6C, 0x6E, 0x20, 0x75, 0x6E, 0x64, 0x20, 0x54,
     0x61, 0x73, 0x74, 0x65, 0x20, 0x64, 0x72, 0x81,
     0x63, 0x6B, 0x65, 0x6E, 0x0D, 0x0A, 0x00, 0x49,
     0x4F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53,
     0x59, 0x53, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x20,
     0x20, 0x20, 0x53, 0x59, 0x53, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
   };

void PrintStatus( BYTE status ) {

  struct ERR_MSG {
    int no;
    char *name;
  };

  static ERR_MSG errmsg[] =
  { // { 0x00, "successful completion"},
    { 0x01, "invalid function in AH or invalid parameter"},
    { 0x02, "address mark not found"},
    { 0x03, "disk write-protected"},
    { 0x04, "sector not found/read error"},
    { 0x05, "reset failed (hard disk)"},
    { 0x06, "disk changed (floppy)"},
    { 0x07, "drive parameter activity failed (hard disk)"},
    { 0x08, "DMA overrun"},
    { 0x09, "data boundary error (attempted DMA across 64K boundary or >80h sectors)"},
    { 0x0A, "bad sector detected (hard disk)"},
    { 0x0B, "bad track detected (hard disk)"},
    { 0x0C, "unsupported track or invalid media"},
    { 0x0D, "invalid number of sectors on format (PS/2 hard disk)"},
    { 0x0E, "control data address mark detected (hard disk)"},
    { 0x0F, "DMA arbitration level out of range (hard disk)"},
    { 0x10, "uncorrectable CRC or ECC error on read"},
    { 0x11, "data ECC corrected (hard disk)"},
    { 0x20, "controller failure"},
    { 0x31, "no such drive (Compaq)"},
    { 0x32, "incorrect drive type stored in CMOS (Compaq)"},
    { 0x40, "seek failed"},
    { 0x80, "timeout (not ready)"},
    { 0xAA, "drive not ready (hard disk)"},
    { 0xBB, "undefined error (hard disk)"},
    { 0xCC, "write fault (hard disk)"},
    { 0xE0, "status register error (hard disk)" },
    { 0xFF, "sense operation failed (hard disk)"},
    { -1,   ""}
  };

  ERR_MSG *perrmsg = errmsg;
  while ( (perrmsg->no) >= 0) {
    if (perrmsg++->no == status) {
      cout << (--perrmsg)->name << endl;
      exit(1);
    }
  };

  if (status) {
    cout << "unknown error " << int(status) << endl;
    exit(status);
  }
}

#ifdef FORMAT
// Formatiert Diskette
void format144( char drive ) {
  char track, head, sector;
  static char status;
  static char buffer[18*4];
  char *buf;

  if (bReset) {
    bReset = false;
    asm {
      mov ax,0x0000
      mov dl,drive
      int 0x13
      mov status,ah
    };

    if (status)
      PrintStatus( status );
  };

  asm { // Disketten-Parameter setzen:
    mov ax,0x1800
    mov dl,drive
    mov cl,18  // 18 Sektoren/Spur
    mov ch,79  // 80 Spuren (0-79)
    int 0x13
    mov status,ah
  }

  if (status)
    PrintStatus( status );

  // Durch das Z„hlen von 79 auf 0 spare ich mir ein groáes Seek!
  for (track=79;track>=0;track--)
    for (head=1;head>=0;head--) {
      buf = buffer;
      for (sector=1;sector<=18;sector++) {
	*(buf++)=track;
	*(buf++)=head;
	*(buf++)=sector;
	*(buf++)=2;
      };
      asm {
	mov ax,0x0512
	mov ch,track
	mov dl,drive
	mov dh,head
	push es
	push ds
	pop es
	mov bx,offset buffer
	int 0x13
	mov status,ah
	pop es
      }
      if (status)
	PrintStatus( status );
    };
}
#else // #ifdef FORMAT
// L”scht Diskette durch šberschreiben aller Sektoren mit Nullen
void clear144( char drive ) {
  char track, head;
  static char status;
  char far *nullblk;

  nullblk=(char far*) calloc(18,512);

  if (bReset) {
    bReset = false;
    asm {
      mov ax,0x0000
      mov dl,drive
      int 0x13
      mov status,ah
    };

    if (status)
      PrintStatus( status );
  };

  for (track=79;track>=0;track--)
    for (head=1;head>=0;head--) {

      asm {
	mov ax,0x0312
	mov dl,drive
	mov dh,head
	mov ch,track
	mov cl,1
	push es
	les bx,dword ptr nullblk
	int 0x13
	mov status,ah
	pop es
      };

      if (status)
	PrintStatus( status );
    };

  free((void*)nullblk);
}
#endif // #ifdef FORMAT

// schreibt Bootblk & FATs & Root
void dinit144( char drive ) {
  static char status;
  char far *nullblk;

  nullblk=(char far*) calloc(18,512);

  if (bReset) {
    bReset = false;
    asm {
      mov ax,0x0000
      mov dl,drive
      int 0x13
      mov status,ah
    };

    if (status)
      PrintStatus( status );
  };

  asm { // L”schen von Track 0 / Head 1 / Sect. 1-15
    mov ax,0x030F
    mov dl,drive
    mov dh,1
    mov cx,1
    push es
    les bx,dword ptr nullblk
    int 0x13
    mov status,ah
    pop es
  };

  if (status)
    PrintStatus( status );

  asm { // L”schen von Track 0 / Head 0
    mov ax,0x0312
    mov dl,drive
    mov dh,0
    mov cx,1
    push es
    les bx,dword ptr nullblk
    int 0x13
    mov status,ah
    pop es
  }

  if (status)
    PrintStatus( status );

  asm { // Schreiben des Boot-Blockes
    mov ax,0x0301
    mov dl,drive
    mov dh,0
    mov cx,1
    push es
    push ds
    pop es
    mov bx,offset bootblk
    int 0x13
    mov status,ah
    pop es
  }

  if (status)
    PrintStatus( status );

  // FAT-Eintr„ge: Cylinder 2 ist belegt!
  nullblk[0] = 0xF0;
  nullblk[1] = 0xFF;
  nullblk[2] = 0xFF;

  asm { // Schreiben der FATs: FAT 1
    mov ax,0x0301
    mov dl,drive
    mov dh,0
    mov cx,2
    push es
    les bx,dword ptr nullblk
    int 0x13
    mov status,ah
    pop es
  }

  if (status)
    PrintStatus( status );

  asm { // Schreiben der FATs: FAT 2
    mov ax,0x0301
    mov dl,drive
    mov dh,0
    mov cx,11
    push es
    les bx,dword ptr nullblk
    int 0x13
    mov status,ah
    pop es
  }

  if (status)
    PrintStatus( status );

  free((void*)nullblk);
}

int main( int argc, char *argv[] ) {
#ifdef FORMAT
  format144(0);
#else
  clear144(0);
#endif
  dinit144(0);
  return argc-argc+argv[0][0]-argv[0][0]; // um die Warning zu vermeiden!
}
